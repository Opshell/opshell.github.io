---
title: Index Signatures(索引簽章) - 一拳打碎隕石
author: Opshell
createdAt: '2025-01-17'
categories:
  - 使用實例
tags:
  - TypeScript
  - 使用實例
  - Type Safety
editLink: true
isPublished: true
image: ''
description: ''
keywords: ''

---
## 索引簽章
在 `TypeScript` 中，用來定義 `Object(物件)` 或者 `Class(類別)` 的 索引類型及對應索引值的類型。

讓我們透過一些簡單的實例來看看是怎麼操作的。
今天我們為了組資料方便，把 Get 要用的 params 弄成了一個物件，但是我們要送出請求時，還是需要把他解析在網址後面 ~~(好啦  我們先假裝 axios 沒有 params 可以帶好嗎?)~~。
所以我們設計了一個公用函數：
```ts
function formatToURLParams(data: {
    [key: string]: number | string | number[] | string[]
}) {
    const params = new URLSearchParams();
    Object.keys(data).forEach((key) => {
        if (Array.isArray(data[key])) {
            if (data[key].length > 0) {
                data[key].forEach((item) => {
                    params.append(key, item.toString());
                });
            } else {
                params.append(key, '');
            }
        } else {
            params.append(key, data[key].toString());
        }
    });

    return params;
}
```
`data` 的型別就是所謂的 `Index Signatures(索引簽章)`， 這樣不管 `data` 這個物件進來有幾組值，只要符合規則就可以組出我們想要的字串。

接下來我們來使用他：
```ts
interface iGetCalendarData {
    date: string;
    userId: number;
    target: number[];
}

function getCalendar (data: iGetCalendarData) {
    const paramsString = formatToURLParams(data);
    axios({
        url: `/api/getCalendar?${paramsString}`,
        method: 'GET'
    }).then((res) => {...});
}
```
::: danger 錯誤
- 類型 'iGetCalendarData' 的引數不可指派給類型'{ [key: string]: string | number | number[] | string[]; }' 的參數。

- 類型 'string' 的索引簽章在類型 'iGetCalendarData' 中遺失。ts(2345)
:::

奇怪，我不是在 `formatToURLParams` 定義了可以接受一堆參數嗎？也沒送特別奇怪的類型，為什麼會說 `iGetCalendarData` 類型不符合呢？
這個問題的核心在於 `iGetCalendarData`{.typescript} 類型與 `formatToURLParams` 函數所期望的參數類型不匹配。

`formatToURLParams` 期望接收一個物件，該物件的值可以是 number、string、number[] 或 string[]。但是，`iGetCalendarData`{.typescript} 類型的定義並不符合這個要求。

這個函數的目的是將一個物件轉換為 URL 查詢參數。它遍歷物件的每個 Key，並將其值轉換為字串後添加到 URLSearchParams 中。

問題出在 iGetCalendarData 類型的定義上。假設 iGetCalendarData 類型如下：

```ts
interface iGetCalendarData {
    // 假設有一些屬性
    date: string;
    target: number[];
    // 其他屬性...
}
```

這個類型缺少一個索引簽章，這意味著它不能被用作 `formatToURLParams` 的參數。

換句話說，在typescript 中，他不會自動把你的索引簽章解開、比對，當你定義一個物件類型時，如果你想讓它能夠接受任意的 key-value 對，你需要也為他定義索引簽章來定義這種結構。

要解決這個問題，我們可以為 `iGetCalendarData`{.typescript} 添加一個索引簽章，使其符合 `formatToURLParams` 的參數要求：

```ts
interface iGetCalendarData {
    [key: string]: string | number | number[] | string[];
    date: string;
    target: number[];
    // 其他屬性...
}
```

這樣，`iGetCalendarData`{.typescript} 類型就可以被用作 `formatToURLParams` 函數的參數了。


## 進階思考
在隕石開發的時候，`Index Signatures(索引簽章)` 的確是一個快速的、方便的解決方案，但是就像埼玉一拳打碎隕石，碎石也波及了Z市，`Index Signatures(索引簽章)`也是有他的副作用在，在多人協作的大專案中，大家都可能對這個函式做修改，不斷的添加型別，今天加一個 `enable: boolean`，就要在簽章上擴充，除了管理麻煩，在過多的簽章屬性上，不就同等於 `any` 了嗎? anyscript 可是不行的，失去了 `Type Safety`。

在開發時，考量每個函式具體的用途，盡量避免使用過於寬泛的索引簽章類型，改用具體的介面或類型定義來描述物件的結構，這樣可以提高程式碼的可讀性和可維護性。
如果真的是比較靈活的函式，可以考慮使用`泛型 (Generics)` 來定義函式，這樣可以在保留靈活性的同時，仍然保持類型的嚴格性。

泛型在專案中使用率不高，卻是很重要的技巧，在下一篇文章中，讓我們用同個例子衍伸泛型的用法，讓我們學習如何更優雅的開發。