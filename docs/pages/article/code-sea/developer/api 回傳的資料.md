前後端分離時 新增、修改 請求， 後端丟結果回來的時候 要順便帶目前的資料狀態 還是說 另外開一支查詢的api?

在前後端分離的架構中，當進行新增或修改請求時，後端應該如何返回結果以及是否需要帶回目前的資料狀態，這取決於具體的需求和系統設計。以下是兩種常見的做法及其優缺點：

1. 在新增或修改請求的回應中帶回目前的資料狀態
優點：
減少請求數量：一次請求即可獲取更新後的資料狀態，減少了額外的查詢請求。
即時性：前端可以立即獲取最新的資料狀態，無需再發起查詢請求。

缺點：
回應數據量可能較大：如果資料狀態較大，回應的數據量也會較大。
複雜性增加：後端需要在處理新增或修改請求時，同時處理資料狀態的查詢和返回。

示例：
```ts
// 前端發送新增或修改請求
sendRequest('/api/resource', 'POST', newData).then((res) => {
    if (res.status) {
        // 新增或修改成功後，發送查詢請求
        sendRequest('/api/resource/current').then((queryRes) => {
            if (queryRes.status) {
                // 更新本地狀態
                currentData.value = queryRes.data;
            } else {
                // 處理查詢錯誤
                console.error(queryRes.message);
            }
        });
    } else {
        // 處理新增或修改錯誤
        console.error(res.message);
    }
});
```

2. 另外開一支查詢的 API
優點：
單一職責原則：每個 API 僅負責一項任務，新增或修改 API 只處理數據變更，查詢 API 只處理數據查詢。
靈活性：可以根據需要單獨調用查詢 API，獲取最新的資料狀態。

缺點：
增加請求數量：需要額外發起一次查詢請求，可能會增加網路負擔。
延遲：前端需要等待兩次請求的回應，才能獲取最新的資料狀態。

示例：
```ts
// 前端發送新增或修改請求
sendRequest('/api/resource', 'POST', newData).then((res) => {
    if (res.status) {
        // 新增或修改成功後，發送查詢請求
        sendRequest('/api/resource/current').then((queryRes) => {
            if (queryRes.status) {
                // 更新本地狀態
                currentData.value = queryRes.data;
            } else {
                // 處理查詢錯誤
                console.error(queryRes.message);
            }
        });
    } else {
        // 處理新增或修改錯誤
        console.error(res.message);
    }
});
```

總結
選擇哪種方式取決於具體的需求和系統設計。如果希望減少請求數量並且即時獲取最新的資料狀態，可以在新增或修改請求的回應中帶回資料狀態。如果希望遵循單一職責原則並且需要靈活的查詢能力，可以另外開一支查詢的 API。

在寫專案的時候，常常思考一個問題，
新增、修改的 api 請求，
為了維持畫面和資料庫資料的一致性，
在請求結束時要和後端拿目前最新的資料狀態，
我個人用過的做法有兩個：

1.後端丟結果回來的時候，要順便帶新的資料狀態
2.另外開一支查詢的api

各有其優缺點，
1. 是網路請求會少一點，頁面刷新也快一點
2. 是符合單一職責原則，後端處理也相對單純

想了解各位大大在這個情況下都是怎麼選擇的呢?

不過突然又想到個問題，
新增時，回傳新增後產生的id
也算在，1的情況嗎XD?
還是只是新增的基本操作?

10:20 Brave 我們大部分用1
10:20 空中貓纜 2
10:21 檸檬派 2
10:21 Opshell 話說 為了這個開投票會很怪嗎XD?
10:21 Opshell 喔好吧  我不能開XD
10:23 空中貓纜 小專案用1當然沒問題 但都需要後台修改了 我一定選2
10:25 轉職成功 2
10:25 Vimist 2
10:26 Vimist 其實可以用討論串啦 XD 是因為怕洗頻的話
10:26 Vimist 不過我猜其實最終也不會太洗
10:26 轉職成功 不會洗頻拉 因為會講話就我麼幾個ＸＤ
10:26 鱈魚 1+2
10:28 Opshell 不過突然又想到個問題，
新增時，回傳新增後產生的id
也算在，1的情況嗎XD?
還是只是新增的基本操作?
10:30 空中貓纜 都回你列表了直接換掉不是？
10:31 空中貓纜 還是你的命題只有在修改的那筆資料上
10:31 日安 2
10:31 Opshell 所以  新增一筆資料後  也是直接在尻一個 列表回來嗎?
10:31 Astolfo 本來就該開一隻查詢
10:32 Astolfo 你新增進去的如果是既有的列表API，戳他就可以
10:33 空中貓纜 不然要更新什麼 修改的值是前端送的 還要後端在給一次嗎？
10:33 空中貓纜 貼圖
10:34 Opshell 大部分單筆新增修改   這種只需要極少回傳  (比如傳一個 新增後的 id)
10:34 檸檬派 restful有沒有真的後端時做出不同的method(get, post, put, delete)都同一支API?
10:34 Opshell 我是都選 1 做簡單操作
10:35 空中貓纜 這我倒是會給
10:36 Vimist 多客戶端同時操作的結果準確度考量嗎?
10:36 Opshell 但是有時候  需要大量回傳 、頁面變動比較大或者是有 清除 暫存的需求  理論上是2  但是有時候還是會掙扎一下XD
10:36 Opshell 這個也有XD
10:36 空中貓纜 那就不會是小專案了
10:37 Vimist 那 2 聽起來還是舒服點吧
1 不回到給你時最準確的感覺也情有可原
2 就說不過去了
10:38 Ken 全端 1
分離 2
10:38 空中貓纜 不是你一個人做分離嗎（x
10:39 Opshell 不是你一個人做分離嗎（o
10:40 Vimist 某方面來說, 1 在某些考量下反而耗頻寬?
e.g. 批次處理需求
10:41 Opshell 貼圖
10:41 Vimist 以及要拿的列表開始變大 (?
10:42 空中貓纜 不管怎麼說 單一原則還是比較好 但開發上就真的比較慢
10:42 Vimist 2. 就前端可以自己拿捏什麼時候要抓最新的
